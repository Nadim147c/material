// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.1

// Built By: go install

package dynamic

import (
	"errors"
	"fmt"
)

const (
	// ConstraintExact is a Constraint of type Exact.
	ConstraintExact Constraint = 0
	// ConstraintNearer is a Constraint of type Nearer.
	ConstraintNearer Constraint = 1
	// ConstraintFarther is a Constraint of type Farther.
	ConstraintFarther Constraint = 2
)

var ErrInvalidConstraint = errors.New("not a valid Constraint")

const _ConstraintName = "exactnearerfarther"

var _ConstraintMap = map[Constraint]string{
	ConstraintExact:   _ConstraintName[0:5],
	ConstraintNearer:  _ConstraintName[5:11],
	ConstraintFarther: _ConstraintName[11:18],
}

// String implements the Stringer interface.
func (x Constraint) String() string {
	if str, ok := _ConstraintMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Constraint(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Constraint) IsValid() bool {
	_, ok := _ConstraintMap[x]
	return ok
}

var _ConstraintValue = map[string]Constraint{
	_ConstraintName[0:5]:   ConstraintExact,
	_ConstraintName[5:11]:  ConstraintNearer,
	_ConstraintName[11:18]: ConstraintFarther,
}

// ParseConstraint attempts to convert a string to a Constraint.
func ParseConstraint(name string) (Constraint, error) {
	if x, ok := _ConstraintValue[name]; ok {
		return x, nil
	}
	return Constraint(0), fmt.Errorf("%s is %w", name, ErrInvalidConstraint)
}

// MarshalText implements the text marshaller method.
func (x Constraint) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Constraint) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseConstraint(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *Constraint) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// PlatformPhone is a Platform of type Phone.
	PlatformPhone Platform = 0
	// PlatformWatch is a Platform of type Watch.
	PlatformWatch Platform = 1
)

var ErrInvalidPlatform = errors.New("not a valid Platform")

const _PlatformName = "phonewatch"

var _PlatformMap = map[Platform]string{
	PlatformPhone: _PlatformName[0:5],
	PlatformWatch: _PlatformName[5:10],
}

// String implements the Stringer interface.
func (x Platform) String() string {
	if str, ok := _PlatformMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Platform(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Platform) IsValid() bool {
	_, ok := _PlatformMap[x]
	return ok
}

var _PlatformValue = map[string]Platform{
	_PlatformName[0:5]:  PlatformPhone,
	_PlatformName[5:10]: PlatformWatch,
}

// ParsePlatform attempts to convert a string to a Platform.
func ParsePlatform(name string) (Platform, error) {
	if x, ok := _PlatformValue[name]; ok {
		return x, nil
	}
	return Platform(0), fmt.Errorf("%s is %w", name, ErrInvalidPlatform)
}

// MarshalText implements the text marshaller method.
func (x Platform) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Platform) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParsePlatform(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *Platform) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// TonePolarityDarker is a TonePolarity of type Darker.
	TonePolarityDarker TonePolarity = 0
	// TonePolarityLighter is a TonePolarity of type Lighter.
	TonePolarityLighter TonePolarity = 1
	// TonePolarityNearer is a TonePolarity of type Nearer.
	TonePolarityNearer TonePolarity = 2
	// TonePolarityFarther is a TonePolarity of type Farther.
	TonePolarityFarther TonePolarity = 3
	// TonePolarityRelativeDarker is a TonePolarity of type Relative_darker.
	TonePolarityRelativeDarker TonePolarity = 4
	// TonePolarityRelativeLighter is a TonePolarity of type Relative_lighter.
	TonePolarityRelativeLighter TonePolarity = 5
)

var ErrInvalidTonePolarity = errors.New("not a valid TonePolarity")

const _TonePolarityName = "darkerlighternearerfartherrelative_darkerrelative_lighter"

var _TonePolarityMap = map[TonePolarity]string{
	TonePolarityDarker:          _TonePolarityName[0:6],
	TonePolarityLighter:         _TonePolarityName[6:13],
	TonePolarityNearer:          _TonePolarityName[13:19],
	TonePolarityFarther:         _TonePolarityName[19:26],
	TonePolarityRelativeDarker:  _TonePolarityName[26:41],
	TonePolarityRelativeLighter: _TonePolarityName[41:57],
}

// String implements the Stringer interface.
func (x TonePolarity) String() string {
	if str, ok := _TonePolarityMap[x]; ok {
		return str
	}
	return fmt.Sprintf("TonePolarity(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TonePolarity) IsValid() bool {
	_, ok := _TonePolarityMap[x]
	return ok
}

var _TonePolarityValue = map[string]TonePolarity{
	_TonePolarityName[0:6]:   TonePolarityDarker,
	_TonePolarityName[6:13]:  TonePolarityLighter,
	_TonePolarityName[13:19]: TonePolarityNearer,
	_TonePolarityName[19:26]: TonePolarityFarther,
	_TonePolarityName[26:41]: TonePolarityRelativeDarker,
	_TonePolarityName[41:57]: TonePolarityRelativeLighter,
}

// ParseTonePolarity attempts to convert a string to a TonePolarity.
func ParseTonePolarity(name string) (TonePolarity, error) {
	if x, ok := _TonePolarityValue[name]; ok {
		return x, nil
	}
	return TonePolarity(0), fmt.Errorf("%s is %w", name, ErrInvalidTonePolarity)
}

// MarshalText implements the text marshaller method.
func (x TonePolarity) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *TonePolarity) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseTonePolarity(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *TonePolarity) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// VariantMonochrome is a Variant of type Monochrome.
	VariantMonochrome Variant = 0
	// VariantNeutral is a Variant of type Neutral.
	VariantNeutral Variant = 1
	// VariantTonalSpot is a Variant of type Tonal_spot.
	VariantTonalSpot Variant = 2
	// VariantVibrant is a Variant of type Vibrant.
	VariantVibrant Variant = 3
	// VariantExpressive is a Variant of type Expressive.
	VariantExpressive Variant = 4
	// VariantFidelity is a Variant of type Fidelity.
	VariantFidelity Variant = 5
	// VariantContent is a Variant of type Content.
	VariantContent Variant = 6
	// VariantRainbow is a Variant of type Rainbow.
	VariantRainbow Variant = 7
	// VariantFruitSalad is a Variant of type Fruit_salad.
	VariantFruitSalad Variant = 8
)

var ErrInvalidVariant = errors.New("not a valid Variant")

const _VariantName = "monochromeneutraltonal_spotvibrantexpressivefidelitycontentrainbowfruit_salad"

var _VariantMap = map[Variant]string{
	VariantMonochrome: _VariantName[0:10],
	VariantNeutral:    _VariantName[10:17],
	VariantTonalSpot:  _VariantName[17:27],
	VariantVibrant:    _VariantName[27:34],
	VariantExpressive: _VariantName[34:44],
	VariantFidelity:   _VariantName[44:52],
	VariantContent:    _VariantName[52:59],
	VariantRainbow:    _VariantName[59:66],
	VariantFruitSalad: _VariantName[66:77],
}

// String implements the Stringer interface.
func (x Variant) String() string {
	if str, ok := _VariantMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Variant(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Variant) IsValid() bool {
	_, ok := _VariantMap[x]
	return ok
}

var _VariantValue = map[string]Variant{
	_VariantName[0:10]:  VariantMonochrome,
	_VariantName[10:17]: VariantNeutral,
	_VariantName[17:27]: VariantTonalSpot,
	_VariantName[27:34]: VariantVibrant,
	_VariantName[34:44]: VariantExpressive,
	_VariantName[44:52]: VariantFidelity,
	_VariantName[52:59]: VariantContent,
	_VariantName[59:66]: VariantRainbow,
	_VariantName[66:77]: VariantFruitSalad,
}

// ParseVariant attempts to convert a string to a Variant.
func ParseVariant(name string) (Variant, error) {
	if x, ok := _VariantValue[name]; ok {
		return x, nil
	}
	return Variant(0), fmt.Errorf("%s is %w", name, ErrInvalidVariant)
}

// MarshalText implements the text marshaller method.
func (x Variant) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Variant) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseVariant(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *Variant) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// Version2021 is a Version of type 2021.
	Version2021 Version = 2021
	// Version2025 is a Version of type 2025.
	Version2025 Version = 2025
)

var ErrInvalidVersion = errors.New("not a valid Version")

const _VersionName = "20212025"

var _VersionMap = map[Version]string{
	Version2021: _VersionName[0:4],
	Version2025: _VersionName[4:8],
}

// String implements the Stringer interface.
func (x Version) String() string {
	if str, ok := _VersionMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Version(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Version) IsValid() bool {
	_, ok := _VersionMap[x]
	return ok
}

var _VersionValue = map[string]Version{
	_VersionName[0:4]: Version2021,
	_VersionName[4:8]: Version2025,
}

// ParseVersion attempts to convert a string to a Version.
func ParseVersion(name string) (Version, error) {
	if x, ok := _VersionValue[name]; ok {
		return x, nil
	}
	return Version(0), fmt.Errorf("%s is %w", name, ErrInvalidVersion)
}

// MarshalText implements the text marshaller method.
func (x Version) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Version) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseVersion(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *Version) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

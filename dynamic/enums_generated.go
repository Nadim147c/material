// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.1

// Built By: go install

package dynamic

import (
	"errors"
	"fmt"
)

const (
	// ConstraintExact is a DeltaConstraint of type Constraint_exact.
	ConstraintExact DeltaConstraint = iota
	// ConstraintNearer is a DeltaConstraint of type Constraint_nearer.
	ConstraintNearer
	// ConstraintFarther is a DeltaConstraint of type Constraint_farther.
	ConstraintFarther
)

var ErrInvalidDeltaConstraint = errors.New("not a valid DeltaConstraint")

const _DeltaConstraintName = "constraint_exactconstraint_nearerconstraint_farther"

var _DeltaConstraintMap = map[DeltaConstraint]string{
	ConstraintExact:   _DeltaConstraintName[0:16],
	ConstraintNearer:  _DeltaConstraintName[16:33],
	ConstraintFarther: _DeltaConstraintName[33:51],
}

// String implements the Stringer interface.
func (x DeltaConstraint) String() string {
	if str, ok := _DeltaConstraintMap[x]; ok {
		return str
	}
	return fmt.Sprintf("DeltaConstraint(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x DeltaConstraint) IsValid() bool {
	_, ok := _DeltaConstraintMap[x]
	return ok
}

var _DeltaConstraintValue = map[string]DeltaConstraint{
	_DeltaConstraintName[0:16]:  ConstraintExact,
	_DeltaConstraintName[16:33]: ConstraintNearer,
	_DeltaConstraintName[33:51]: ConstraintFarther,
}

// ParseDeltaConstraint attempts to convert a string to a DeltaConstraint.
func ParseDeltaConstraint(name string) (DeltaConstraint, error) {
	if x, ok := _DeltaConstraintValue[name]; ok {
		return x, nil
	}
	return DeltaConstraint(0), fmt.Errorf("%s is %w", name, ErrInvalidDeltaConstraint)
}

// MarshalText implements the text marshaller method.
func (x DeltaConstraint) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *DeltaConstraint) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseDeltaConstraint(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *DeltaConstraint) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// Phone is a Platform of type Phone.
	Phone Platform = iota
	// Watch is a Platform of type Watch.
	Watch
)

var ErrInvalidPlatform = errors.New("not a valid Platform")

const _PlatformName = "phonewatch"

var _PlatformMap = map[Platform]string{
	Phone: _PlatformName[0:5],
	Watch: _PlatformName[5:10],
}

// String implements the Stringer interface.
func (x Platform) String() string {
	if str, ok := _PlatformMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Platform(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Platform) IsValid() bool {
	_, ok := _PlatformMap[x]
	return ok
}

var _PlatformValue = map[string]Platform{
	_PlatformName[0:5]:  Phone,
	_PlatformName[5:10]: Watch,
}

// ParsePlatform attempts to convert a string to a Platform.
func ParsePlatform(name string) (Platform, error) {
	if x, ok := _PlatformValue[name]; ok {
		return x, nil
	}
	return Platform(0), fmt.Errorf("%s is %w", name, ErrInvalidPlatform)
}

// MarshalText implements the text marshaller method.
func (x Platform) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Platform) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParsePlatform(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *Platform) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// ToneDarker is a TonePolarity of type Tone_darker.
	ToneDarker TonePolarity = iota
	// ToneLighter is a TonePolarity of type Tone_lighter.
	ToneLighter
	// ToneNearer is a TonePolarity of type Tone_nearer.
	ToneNearer
	// ToneFarther is a TonePolarity of type Tone_farther.
	ToneFarther
	// ToneRelativeDarker is a TonePolarity of type Tone_relative_darker.
	ToneRelativeDarker
	// ToneRelativeLighter is a TonePolarity of type Tone_relative_lighter.
	ToneRelativeLighter
)

var ErrInvalidTonePolarity = errors.New("not a valid TonePolarity")

const _TonePolarityName = "tone_darkertone_lightertone_nearertone_farthertone_relative_darkertone_relative_lighter"

var _TonePolarityMap = map[TonePolarity]string{
	ToneDarker:          _TonePolarityName[0:11],
	ToneLighter:         _TonePolarityName[11:23],
	ToneNearer:          _TonePolarityName[23:34],
	ToneFarther:         _TonePolarityName[34:46],
	ToneRelativeDarker:  _TonePolarityName[46:66],
	ToneRelativeLighter: _TonePolarityName[66:87],
}

// String implements the Stringer interface.
func (x TonePolarity) String() string {
	if str, ok := _TonePolarityMap[x]; ok {
		return str
	}
	return fmt.Sprintf("TonePolarity(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TonePolarity) IsValid() bool {
	_, ok := _TonePolarityMap[x]
	return ok
}

var _TonePolarityValue = map[string]TonePolarity{
	_TonePolarityName[0:11]:  ToneDarker,
	_TonePolarityName[11:23]: ToneLighter,
	_TonePolarityName[23:34]: ToneNearer,
	_TonePolarityName[34:46]: ToneFarther,
	_TonePolarityName[46:66]: ToneRelativeDarker,
	_TonePolarityName[66:87]: ToneRelativeLighter,
}

// ParseTonePolarity attempts to convert a string to a TonePolarity.
func ParseTonePolarity(name string) (TonePolarity, error) {
	if x, ok := _TonePolarityValue[name]; ok {
		return x, nil
	}
	return TonePolarity(0), fmt.Errorf("%s is %w", name, ErrInvalidTonePolarity)
}

// MarshalText implements the text marshaller method.
func (x TonePolarity) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *TonePolarity) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseTonePolarity(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *TonePolarity) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// Monochrome is a Variant of type Monochrome.
	Monochrome Variant = iota
	// Neutral is a Variant of type Neutral.
	Neutral
	// TonalSpot is a Variant of type Tonal_spot.
	TonalSpot
	// Vibrant is a Variant of type Vibrant.
	Vibrant
	// Expressive is a Variant of type Expressive.
	Expressive
	// Fidelity is a Variant of type Fidelity.
	Fidelity
	// Content is a Variant of type Content.
	Content
	// Rainbow is a Variant of type Rainbow.
	Rainbow
	// FruitSalad is a Variant of type Fruit_salad.
	FruitSalad
)

var ErrInvalidVariant = errors.New("not a valid Variant")

const _VariantName = "monochromeneutraltonal_spotvibrantexpressivefidelitycontentrainbowfruit_salad"

var _VariantMap = map[Variant]string{
	Monochrome: _VariantName[0:10],
	Neutral:    _VariantName[10:17],
	TonalSpot:  _VariantName[17:27],
	Vibrant:    _VariantName[27:34],
	Expressive: _VariantName[34:44],
	Fidelity:   _VariantName[44:52],
	Content:    _VariantName[52:59],
	Rainbow:    _VariantName[59:66],
	FruitSalad: _VariantName[66:77],
}

// String implements the Stringer interface.
func (x Variant) String() string {
	if str, ok := _VariantMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Variant(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Variant) IsValid() bool {
	_, ok := _VariantMap[x]
	return ok
}

var _VariantValue = map[string]Variant{
	_VariantName[0:10]:  Monochrome,
	_VariantName[10:17]: Neutral,
	_VariantName[17:27]: TonalSpot,
	_VariantName[27:34]: Vibrant,
	_VariantName[34:44]: Expressive,
	_VariantName[44:52]: Fidelity,
	_VariantName[52:59]: Content,
	_VariantName[59:66]: Rainbow,
	_VariantName[66:77]: FruitSalad,
}

// ParseVariant attempts to convert a string to a Variant.
func ParseVariant(name string) (Variant, error) {
	if x, ok := _VariantValue[name]; ok {
		return x, nil
	}
	return Variant(0), fmt.Errorf("%s is %w", name, ErrInvalidVariant)
}

// MarshalText implements the text marshaller method.
func (x Variant) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Variant) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseVariant(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *Variant) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// V2021 is a Version of type 2021.
	V2021 Version = iota + 2021
	// V2025 is a Version of type 2025.
	V2025 Version = iota + 2024
)

var ErrInvalidVersion = errors.New("not a valid Version")

const _VersionName = "20212025"

var _VersionMap = map[Version]string{
	V2021: _VersionName[0:4],
	V2025: _VersionName[4:8],
}

// String implements the Stringer interface.
func (x Version) String() string {
	if str, ok := _VersionMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Version(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Version) IsValid() bool {
	_, ok := _VersionMap[x]
	return ok
}

var _VersionValue = map[string]Version{
	_VersionName[0:4]: V2021,
	_VersionName[4:8]: V2025,
}

// ParseVersion attempts to convert a string to a Version.
func ParseVersion(name string) (Version, error) {
	if x, ok := _VersionValue[name]; ok {
		return x, nil
	}
	return Version(0), fmt.Errorf("%s is %w", name, ErrInvalidVersion)
}

// MarshalText implements the text marshaller method.
func (x Version) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Version) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseVersion(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *Version) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
